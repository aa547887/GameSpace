@* ======================================================================
   Views/Support/Ticket.cshtml（前台 — 穩定貼底 & 泡泡）
   - 僅內容區(#msg-host)捲動；外層不再出頁面滾輪
   - 透過 ResizeObserver / MutationObserver / 多次回補計算，解決右欄晚載入擠高
   - 使用者(我)=右藍；客服=左灰；抽純文字避免「卡片包卡片」
   ====================================================================== *@

@model GamiPort.Areas.social_hub.Controllers.SupportController.TicketVM
@{
    Layout ??= "~/Views/Shared/_Layout.cshtml";
    ViewData["Title"] = $"工單 #{Model.TicketId}";
}

@section Styles {
    <!-- 掛載與後台一致的通用泡泡樣式（含小角標） -->
    <link rel="stylesheet" href="~/css/social_hub/support-bubbles.css" asp-append-version="true" />
    <style>
        /* ===== 只對本頁生效 ===== */
        #support-ticket,
        #support-ticket .st-main-col,
        #support-ticket .st-card-wrap {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }


            #support-ticket .ticket-card {
                display: flex;
                flex-direction: column;
                border-radius: 14px;
                min-height: 0
            }

                #support-ticket .ticket-card .card-header {
                    flex: 0 0 auto;
                    padding: .6rem .9rem
                }

                #support-ticket .ticket-card .card-footer {
                    flex: 0 0 auto;
                    padding: .5rem .75rem .6rem;
                    background: #fafafa;
                    border-top: 1px solid #eee
                }

            /* 只讓內容區滾動，高度由 JS 算到貼底 */
            #support-ticket #msg-host {
                overflow: auto;
                padding: 14px 16px;
                background: #fff;
                min-height: 0
            }

            /* 泡泡：使用者(我)=右藍；客服=左灰 */
            #support-ticket .gp-chat-list {
                display: flex;
                flex-direction: column;
                gap: 8px
            }

            #support-ticket .gp-msg {
                display: flex;
                width: 100%
            }

                #support-ticket .gp-msg.mine {
                    justify-content: flex-end
                }

                #support-ticket .gp-msg.other {
                    justify-content: flex-start
                }

            #support-ticket .gp-bubble {
                max-width: min(78%,640px);
                border-radius: 14px;
                padding: 10px 12px;
                line-height: 1.48;
                font-size: .96rem;
                word-break: break-word;
                box-shadow: 0 1px 1px rgba(0,0,0,.03);
                white-space: pre-wrap
            }

            #support-ticket .gp-msg.mine .gp-bubble {
                background: #2563eb;
                color: #fff;
                border-bottom-right-radius: 8px
            }

            #support-ticket .gp-msg.other .gp-bubble {
                background: #f4f6f8;
                color: #111827;
                border-bottom-left-radius: 8px
            }

            #support-ticket .composer-row .form-control {
                min-height: 44px
            }

            #support-ticket .composer-row .btn {
                min-height: 44px;
                padding: 0 16px
            }

            #support-ticket .conn-ok {
                color: #16a34a
            }

            #support-ticket .conn-warn {
                color: #ca8a04
            }

            #support-ticket .conn-bad {
                color: #dc2626
            }
        /* ===== 僅此頁：用 flex 取代 JS 計算高度，讓中段吃滿可視高度 ===== */
        #support-ticket {
            /* 以視窗高度扣掉上層 Topbar 的高度與間距，令此頁主體至少貼滿畫面 */
            height: calc(100vh - var(--topbar-h, 56px) - var(--topbar-gap, 8px));
            /* 僅此頁：避免由內部內容撐出整頁滾動，改由訊息容器自身滾動 */
            overflow: hidden;
        }

        /* 讓包裹卡片的兩層容器可伸展，並避免子元素被 min-content 撐爆 */
        #support-ticket .st-main-col,
        #support-ticket .st-card-wrap,
        #support-ticket .ticket-card {
            flex: 1 1 auto;
            min-height: 0;
            /* 防止內層內容外溢造成最外層滾動 */
            overflow: hidden;
        }

        /* 讓訊息容器成為唯一捲動區（header/footer 固定高度） */
        #support-ticket #msg-host {
            flex: 1 1 auto;
        }
        /* ===== 僅此頁：將對話容器固定為「10 則單行對話」的可視高度 =====
           - 以共用樣式（support-bubbles.css）的字級與行高為基準
           - 粗估每則訊息的高度 = 泡泡單行高度 + 上方 meta 行高度 + 每列間距
           - 若日後字級或行距有調整，可在此微調變數即可
        */
        #support-ticket {
            --rows: 10;                /* 顯示幾則單行對話的高度（可自行調整） */
            --bubble-fs: .95rem;       /* 與 .support-chat .msg-bubble 同步 */
            --bubble-lh: 1.45;         /* 與 .support-chat .msg-bubble 同步 */
            --meta-h: 1.0rem;          /* 上方 meta 行（徽章+時間）約略高度 */
            --row-gap: 10px;           /* 每列上下間距的平均估值 */
            --row-h: calc(var(--bubble-fs) * var(--bubble-lh) + var(--meta-h) + var(--row-gap));
        }

        /* 以固定高度取代彈性撐滿，讓僅訊息容器自行滾動 */
        #support-ticket #msg-host {
            flex: 1 1 auto;
            height: auto;
            max-height: none;
            overflow-y: auto;
            overflow: auto; /* 僅此容器滾動，維持外層不滾動 */
        }

        /* 讓 card-body 撐開並提供給 #msg-host 可滾動的空間 */
        #support-ticket .ticket-card .card-body {
            flex: 1 1 auto;
            min-height: 0;
            display: flex;
        }
    </style>
}

<div id="support-ticket" class="container py-3">
    <div class="st-main-col">
        <div class="st-card-wrap">
            <div class="card shadow-sm ticket-card">
                <div class="card-header"><strong>工單 #@Model.TicketId</strong></div>

                <div class="card-body p-0">
                    <div id="msg-host"><div class="text-muted p-3">載入中…</div></div>
                </div>

                <div class="card-footer">
                    <div class="input-group composer-row">
                        <input id="msg-text" class="form-control" maxlength="255" placeholder="輸入訊息…" />
                        <button id="btn-send" class="btn btn-primary" type="button">送出</button>
                    </div>
                    <div id="conn-tip" class="small text-muted mt-1">即時連線：連線中…</div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        (()=> {
          const TICKET_ID = @Model.TicketId;
          const scope = document.getElementById('support-ticket');
          const card  = scope.querySelector('.ticket-card');
          const host  = scope.querySelector('#msg-host');
          const tip   = scope.querySelector('#conn-tip');
          const btn   = scope.querySelector('#btn-send');
          const input = scope.querySelector('#msg-text');
          const rightRail = document.querySelector('.right-rail'); // 右側欄
          const getAf = () => document.querySelector('meta[name="request-verification-token"]')?.content || '';

          /* ================= 貼底高度：只讓 #msg-host 捲動 ================= */
          function fitChatHeight(extra=0) {
            if (!card || !host) return;

            const header = card.querySelector('.card-header');
            const footer = card.querySelector('.card-footer');
            const rect   = card.getBoundingClientRect();
            const cardCS = getComputedStyle(card);
            const hostCS = getComputedStyle(host);

            const viewportH = window.innerHeight;
            const headerH   = header?.offsetHeight || 0;
            const footerH   = footer?.offsetHeight || 0;
            const mb        = parseInt(cardCS.marginBottom || '0', 10);
            const padTB     = parseInt(hostCS.paddingTop || '0', 10) + parseInt(hostCS.paddingBottom || '0', 10);

            // 安全緩衝 + 可選的外部額外值
            const SAFE = 10 + (extra||0);

            let h = viewportH - rect.top - headerH - footerH - mb - SAFE;
            h = Math.max(240, Math.floor(h - padTB));

            host.style.height    = h + 'px';
            host.style.maxHeight = h + 'px';
          }

          const isNearBottom = () => (host.scrollTop + host.clientHeight) >= (host.scrollHeight - 40);
          const scrollBottom = () => { host.scrollTop = host.scrollHeight; };
          // 多次排程貼底：避免高度在 reflow 後造成視覺落差（force=true 時無論目前是否貼底皆貼）
          function scheduleStickyScroll(force=false){
  const shouldStick = force || isNearBottom();
  if (!shouldStick) return;
  if (scheduleStickyScroll._busy) return;
  scheduleStickyScroll._busy = true;
  const doScroll = () => { host.scrollTop = host.scrollHeight; };
  doScroll();
  requestAnimationFrame(doScroll);
  setTimeout(doScroll, 80);
  setTimeout(()=>{ doScroll(); scheduleStickyScroll._busy = false; }, 200);
}

          /* ============ 把載入的 HTML 標準化成左右泡泡（抽「純文字」）============ */
          function normalizeBubbles(container){
            if (container.firstElementChild?.classList.contains('gp-chat-list')) return;

            const list = document.createElement('div');
            list.className = 'gp-chat-list';

            Array.from(container.children).forEach(node=>{
              if(!(node instanceof HTMLElement)) return;

              let isMine = false;
              const mineAttr   = node.getAttribute?.('data-mine');
              const senderAttr = node.getAttribute?.('data-sender');
              if (mineAttr === 'true'  || senderAttr === 'user')    isMine = true;
              if (mineAttr === 'false' || senderAttr === 'manager') isMine = false;
              if (mineAttr == null && senderAttr == null) {
                const raw = (node.innerText || '').trim();
                if (/^\s*使用者/.test(raw)) isMine = true;
                else if (/^\s*客服/.test(raw)) isMine = false;
              }

              // 只抽純文字，避免把 .card 樣式嵌入氣泡
              const contentNode = node.querySelector('.msg-text, .message-text, .card-body, .bubble-text') || node;
              const text = (contentNode.textContent || '').replace(/\s+\n/g, '\n').trim();
              if (!text) return;

              const wrap   = document.createElement('div');
              wrap.className = 'gp-msg ' + (isMine ? 'mine' : 'other');

              const bubble = document.createElement('div');
              bubble.className = 'gp-bubble';
              bubble.textContent = text;

              wrap.appendChild(bubble);
              list.appendChild(wrap);
            });

            container.innerHTML = '';
            container.appendChild(list);
          }

          // 追加：將載入的 HTML 轉為「與後台一致」的 support-chat 結構（含小角標）
          function normalizeToSupportChat(container){
            const first = container.firstElementChild;
            if (first && first.classList.contains('support-chat')) return; // 已轉換過

            const root = document.createElement('div');
            root.className = 'support-chat';
            const col  = document.createElement('div');
            col.className = 'd-flex flex-column';
            root.appendChild(col);

            Array.from(container.children).forEach(row=>{
              if(!(row instanceof HTMLElement)) return;
              if(!row.classList.contains('d-flex')) { col.appendChild(row.cloneNode(true)); return; }

              // 原始：有無 justify-content-end 代表靠右（客服），反轉為 mine=使用者靠右
              const isManager = row.classList.contains('justify-content-end');
              const isMine = !isManager; // 使用者=自己（右側）

              const inner = row.querySelector('div');
              if(!inner) return;
              const metaDiv = inner.querySelector('.small.opacity-75');
              const msgDiv  = inner.querySelector('div:last-child');
              const text = (msgDiv?.textContent || '').replace(/\s+\n/g,'\n').trim();
              if (!text) return;

              const metaText = (metaDiv?.textContent || '').trim();
              const timeGuess = /\d{4}\/\d{2}\/\d{2}\s+\d{2}:\d{2}/.exec(metaText)?.[0] || metaText;

              const wrap = document.createElement('div');
              wrap.className = 'msg-row ' + (isMine ? 'mine' : 'other');

              const msgCol = document.createElement('div');
              msgCol.className = 'msg-col';

              const meta = document.createElement('div');
              meta.className = 'msg-meta';
              const badge = document.createElement('span');
              badge.className = isMine ? 'badge bg-secondary' : 'badge bg-warning text-dark';
              badge.textContent = isMine ? '使用者' : '客服';
              const timeSpan = document.createElement('span');
              timeSpan.textContent = timeGuess;
              meta.appendChild(badge); meta.appendChild(timeSpan);

              const bubble = document.createElement('div');
              bubble.className = 'msg-bubble';
              bubble.textContent = text;

              msgCol.appendChild(meta);
              msgCol.appendChild(bubble);
              wrap.appendChild(msgCol);
              col.appendChild(wrap);
            });

            container.innerHTML = '';
            container.appendChild(root);
          }

          // 分頁（事件委派）
          host.addEventListener('click', async (e)=>{
            const a = e.target.closest('a.page-link');
            if (!a) return;
            e.preventDefault();
            const url  = new URL(a.href, location.origin);
            const page = parseInt(url.searchParams.get('page') || '1', 10);
            await loadMessages(page, {keepPosition:false});
            scheduleStickyScroll(true);
          });

          async function loadMessages(page=1, {keepPosition=true}={}){
            const stick = keepPosition ? isNearBottom() : false;
            try{
              const res  = await fetch(`/social_hub/Support/MessageList?id=${TICKET_ID}&page=${page}`, {
                headers:{'X-Requested-With':'XMLHttpRequest'}, credentials:'same-origin'
              });
              const html = await res.text();
              host.innerHTML = html;
              // 前台改用與後台一致的 support-chat 標記與樣式，不再進行 gp-* 結構的重新包裝
              // 保持簡單：直接使用伺服器輸出的結構，支援在對話框內滾動檢視
              // normalizeBubbles(host);
              normalizeToSupportChat(host);
              // 連續回補：處理旁欄或圖片/字體晚載造成的 reflow
              /*fitChatHeight(12);*/
              requestAnimationFrame(()=>{/*fitChatHeight(12);*/});
              setTimeout(()=>{/*fitChatHeight(14);*/}, 60);
              setTimeout(()=>{/*fitChatHeight(16);*/}, 180);

              scheduleStickyScroll(!keepPosition);
            }catch{
              host.innerHTML = `<div class="text-danger p-3">載入失敗，請稍後再試。</div>`;
              /*fitChatHeight(12);*/
            }
          }

          /* ===================== 送出 ===================== */
          let sending = false;
          async function sendMessage(){
            if (sending) return;
            const text = (input.value||'').trim();
            if (!text) return;
            if (text.length > 255){ alert('內容過長，最多 255 字。'); return; }

            sending = true; const old = btn.textContent;
            btn.disabled = true; btn.textContent = '送出中…';

            try{
              const fd = new FormData(); fd.append('text', text);
              const res = await fetch(`/social_hub/Support/SendMessage?id=${TICKET_ID}`, {
                method:'POST', body:fd, credentials:'same-origin',
                headers:{'X-Requested-With':'XMLHttpRequest','RequestVerificationToken':getAf()}
              });
              if (!res.ok){
                const msg = (await res.text()) || `${res.status} ${res.statusText}`;
                alert('送出失敗：' + msg); return;
              }
              input.value = '';
              await loadMessages(1, {keepPosition:false});
              scheduleStickyScroll(true);
            }catch{
              alert('送出失敗：網路或伺服器錯誤');
            }finally{
              btn.disabled = false; btn.textContent = old; sending = false;
            }
          }

          btn.addEventListener('click', sendMessage);
          input.addEventListener('keydown', e=>{
            if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendMessage(); }
          });

          /* ===================== SignalR ===================== */
          let connection=null;
          async function startHub(){
            if (!window.signalR){
              tip.textContent='即時連線：未載入 signalR（仍可使用）';
              tip.className='small conn-warn'; return;
            }
            try{
              connection = new signalR.HubConnectionBuilder()
                .withUrl("/hubs/support",{withCredentials:true})
                .withAutomaticReconnect().build();

              const onAny = async p=>{
                const tid = +((p && (p.ticketId ?? p.TicketId)) || 0);
                if (tid === +TICKET_ID){
                  const stick = isNearBottom();
                  await loadMessages(1,{keepPosition:stick});
                  // 即時推播：一律貼底，確保最新訊息可見
                  scheduleStickyScroll(true);
                }
              };
              connection.on("msg", onAny);
              connection.on("ticket.message", onAny);

              connection.onreconnecting(()=>{ tip.textContent='即時連線：重新連線中…'; tip.className='small conn-warn'; });
              connection.onreconnected(()=>{ tip.textContent='即時連線：已恢復';     tip.className='small conn-ok';   });
              connection.onclose(()=>      { tip.textContent='即時連線：已關閉';     tip.className='small conn-bad';  });

              await connection.start();
              await connection.invoke("Join", TICKET_ID);
              tip.textContent='即時連線：已連線'; tip.className='small conn-ok';

              window.addEventListener('beforeunload', async()=>{
                try{ await connection.invoke("Leave", TICKET_ID);}catch{}
                try{ await connection.stop(); }catch{}
              });
            }catch(err){
              console.warn('[support] hub start failed:', err);
              tip.textContent='即時連線：失敗（仍可使用）'; tip.className='small conn-warn';
            }
          }

          /* ===================== 初始化 ===================== */
          document.addEventListener('DOMContentLoaded', async ()=>{
            /*fitChatHeight(12);*/                    // 先算一次
            await loadMessages(1,{keepPosition:false});
            scheduleStickyScroll(true);
            await startHub();

            // 再補幾次，cover 圖片/字體/右欄晚載
            requestAnimationFrame(()=>{ /*fitChatHeight(12);*/ scrollBottom(); });
            setTimeout(()=>{ /*fitChatHeight(14);*/ scrollBottom(); }, 80);
            setTimeout(()=>{ /*fitChatHeight(16);*/ scrollBottom(); }, 200);
          });
        })();
    </script>
}





