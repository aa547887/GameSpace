@* ======================================================================
   Views/Support/Ticket.cshtml（前台）
   功能：顯示單一工單的對話紀錄，並提供輸入框送出訊息。
   這版做了什麼？
   1) ★ 文字輸入框 maxlength=255（與後端檢核一致，避免 400 被打回）
   2) 送出訊息時一定夾帶 Anti-Forgery Token（從 <meta> 讀）
   3) 成功寫入後「立即」Reload 訊息（後端會廣播 msg，另端也會自動更新）
   4) SignalR 連 /hubs/support，前台走 Join(ticketId) 路線；監聽 "msg"/"ticket.message"
   5) UI 細節：滾動到底、送出中防連點、錯誤提示、連線提示
   需求前提：
   - _Layout 有：<meta name="request-verification-token" content="@af.RequestToken" />
   - Program.cs 已 MapHub<SupportHub>("/hubs/support")
   - 後端 Service 在寫入訊息成功後有廣播 _notifier.TicketMessageAsync(ticketId, ...)
   ====================================================================== *@

@model GamiPort.Areas.social_hub.Controllers.SupportController.TicketVM
@{
    Layout ??= "~/Views/Shared/_Layout.cshtml";
    ViewData["Title"] = $"工單 #{Model.TicketId}";
}

<style>
    :root {
        --chat-h: 68vh;
    }

    @@media (max-width: 992px) {
        :root {
            --chat-h: 62vh;
        }
    }

    .ticket-card {
        height: var(--chat-h);
        display: flex;
        flex-direction: column;
    }

    #msg-host {
        flex: 1 1 auto;
        min-height: 0;
        overflow: auto;
        padding: 16px 18px;
        background: #fff;
    }

    /* 可依你站上配色微調 */
    .conn-ok {
        color: #16a34a;
    }
    /* 綠 */
    .conn-warn {
        color: #ca8a04;
    }
    /* 黃 */
    .conn-bad {
        color: #dc2626;
    }
    /* 紅 */
</style>

<div class="container py-3">
    <div class="d-flex justify-content-between align-items-center mb-2">
        <h5 class="mb-0">工單 #@Model.TicketId</h5>
        <a class="btn btn-outline-secondary btn-sm" href="@Url.Action("MyTickets", "Support", new { area = "social_hub" })">我的客訴</a>
    </div>

    <div class="card shadow-sm ticket-card">
        <div class="card-header py-2"><strong>對話紀錄</strong></div>
        <div class="card-body p-0">
            <div id="msg-host"><div class="text-muted p-3">載入中…</div></div>
        </div>

        <div class="card-footer">
            <div class="input-group">
                @* ★ 與後端一致（255）——避免被後端 400 打回而「看似不即時」 *@
                <input id="msg-text" class="form-control" maxlength="255" placeholder="輸入訊息…" />
                <button id="btn-send" class="btn btn-primary">送出</button>
            </div>
            <div id="conn-tip" class="small text-muted mt-1">即時連線：連線中…</div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        (() => {
          // ===== 常數 / 小工具 =====
          const TICKET_ID = @Model.TicketId;
          const host = document.getElementById('msg-host');
          const tip  = document.getElementById('conn-tip');
          const btn  = document.getElementById('btn-send');
          const input= document.getElementById('msg-text');

          // 從 _Layout 的 <meta> 取得 Anti-Forgery Token（Program.cs 有設定 HeaderName）
          const getAf = () => document.querySelector('meta[name="request-verification-token"]')?.content || '';

          const isNearBottom = () => (host.scrollTop + host.clientHeight) >= (host.scrollHeight - 40);
          const scrollBottom = () => { host.scrollTop = host.scrollHeight; };

          // ===== 載入訊息（保留使用者滾動位置；靠後端 Partial _MessageList.cshtml） =====
          async function reloadMessages() {
            const keepDown = isNearBottom();
            try{
              const res = await fetch(`/social_hub/Support/MessageList?id=${TICKET_ID}`, {
                headers:{'X-Requested-With':'XMLHttpRequest'},
                credentials:'same-origin'
              });
              const html = await res.text();
              host.innerHTML = html;
              if (keepDown) scrollBottom();
            }catch{
              host.innerHTML = `<div class="text-danger p-3">載入失敗，請稍後再試。</div>`;
            }
          }

          // ===== 送出訊息（帶 Anti-forgery；與後端上限 255 同步） =====
          let sending = false;
          async function sendMessage(){
            if (sending) return;
            const text = (input.value || '').trim();
            if (!text) return;

            // 雙重保護（前後端一致 255）
            if (text.length > 255) {
              alert('內容過長，最多 255 字。');
              return;
            }

            sending = true;
            const oldText = btn.textContent;
            btn.disabled = true; btn.textContent = '送出中…';

            try{
              const fd = new FormData();
              fd.append('text', text);
              const res = await fetch(`/social_hub/Support/SendMessage?id=${TICKET_ID}`, {
                method:'POST',
                body: fd,
                credentials:'same-origin',
                headers:{
                  'X-Requested-With':'XMLHttpRequest',
                  'RequestVerificationToken': getAf() // ★ 關鍵：帶 Token 才不會被 400 擋下
                }
              });

              if (!res.ok) {
                const msg = (await res.text()) || `${res.status} ${res.statusText}`;
                alert('送出失敗：' + msg);
                return;
              }

              input.value = '';
              await reloadMessages();
              scrollBottom();
              // 此端自己 reload 後，另一端會因為後端有 _notifier.TicketMessageAsync(...) 而自動收到 "msg" 事件 → 也會更新
            }catch{
              alert('送出失敗：網路或伺服器錯誤');
            }finally{
              btn.disabled = false; btn.textContent = oldText; sending = false;
            }
          }

          btn.addEventListener('click', sendMessage);

          // Enter 直接送出（Shift+Enter 可改成換行，若你將 input 改為 textarea 再調整）
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              sendMessage();
            }
          });

          // ===== SignalR：加入工單群組（前台用 Join） =====
          let connection = null;

          async function startHub(){
            if (!window.signalR) {
              tip.textContent = '即時連線：未載入 signalR（仍可用手動重新整理）';
              tip.className = 'small conn-warn';
              return;
            }
            try{
              connection = new signalR.HubConnectionBuilder()
                .withUrl("/hubs/support", { withCredentials: true })
                .withAutomaticReconnect()
                .build();

              // 除錯訊息（可搭配 Hub 的 Clients.Caller.SendAsync("debug", "...")）
              connection.on("debug", m => console.debug("[support]", m));

              // 相容兩種事件名稱：msg（主事件）/ ticket.message（舊名）
              const onAnyMessage = async (p) => {
                const tid = +((p && (p.ticketId ?? p.TicketId)) || 0);
                if (tid === +TICKET_ID) await reloadMessages();
              };
              connection.on("msg", onAnyMessage);
              connection.on("ticket.message", onAnyMessage);

              connection.onreconnecting(() => { tip.textContent = '即時連線：重新連線中…'; tip.className = 'small conn-warn'; });
              connection.onreconnected(() => { tip.textContent = '即時連線：已恢復';     tip.className = 'small conn-ok';   });
              connection.onclose(() =>       { tip.textContent = '即時連線：已關閉';     tip.className = 'small conn-bad';  });

              await connection.start();
              await connection.invoke("Join", TICKET_ID); // 前台＝使用者路線
              tip.textContent = '即時連線：已連線';
              tip.className = 'small conn-ok';

              // 離頁清理
              window.addEventListener('beforeunload', async () => {
                try { await connection.invoke("Leave", TICKET_ID); } catch {}
                try { await connection.stop(); } catch {}
              });
            }catch(err){
              console.warn('[support] hub start failed:', err);
              tip.textContent = '即時連線：失敗（仍可使用）';
              tip.className = 'small conn-warn';
            }
          }

          // ===== 初始化 =====
          document.addEventListener('DOMContentLoaded', async () => {
            await reloadMessages();
            scrollBottom();
            await startHub();
          });
        })();
    </script>
}
