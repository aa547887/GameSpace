@* =========================
   Home 小屋頁（不公開版）— 詳細註解
   說明：此檔案顯示個人小屋頁面，但目前以「不公開」提示卡片取代主內容。
   只加註解，不改任何邏輯／標記／JS 流程。
   ========================= *@

@model GamiPort.Areas.MemberManagement.ViewModels.HomePageVM

@* 目前僅用於從 Claims 取出使用者識別；若系統 Identity 使用 GUID（常見），int.Parse 會有風險，見下方 NOTE *@
@using System.Security.Claims

@{
    // 頁面標題：使用者暱稱 + 固定字樣
    ViewData["Title"] = $"{Model.UserNickName} 的小屋";

    // 指定佈局頁；請確認對應 Layout 存在於指定路徑
    Layout = "~/Areas/MemberManagement/Views/Shared/_Layout.cshtml";

    // 目前登入者的使用者 ID（操作者）
    // NOTE：這裡假設 ClaimTypes.NameIdentifier 可被解析成「整數」字串。
    // 若你的系統用 ASP.NET Identity 預設 GUID，此處 int.Parse 會拋例外。
    // 建議在 Controller 先把 ActorUserId（int?）放進 ViewModel，View 就不要解析 Claims。
    var currentLoggedInUserId = User.Identity.IsAuthenticated
        ? int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0")
        : 0;

    // 小屋主（被造訪者）的 UserId
    var targetUserId = Model.OwnerUserId;
}

<div class="container" style="max-width: 1000px;">
    <!-- 頁首：暱稱＋造訪次數 -->
    <div class="position-relative  py-4" style="height: 85px;" right: 0px;">
        <!-- 中間置中的標題 -->
        <h5 class="fw-semibold text-center m-0">@Model.UserNickName 的小屋</h5>

        <!-- 右下角的造訪次數 -->
        <div class="position-absolute text-muted small"
             style="right: 16px; bottom: 0;">
            被造訪次數：@Model.VisitCount
        </div>
    </div>

    @* ===== 背景圖／頭像區 =====
       - 背景圖以 object-fit: cover 填滿，避免比例變形
       - 頭像以圓形呈現並覆蓋在背景圖下緣（position-absolute）
       ======================= *@
    <div class="position-relative border rounded overflow-hidden mb-3">
        <img src="@Model.ThemeSrc" alt="Theme" class="w-100" style="height: 200px; object-fit: cover;" />
        <div class="position-absolute" style="left: 30px; top: 30px;">
            <img src="@Model.UserPictureSrc" alt="UserPicture"
                 class="rounded-circle border bg-white"
                 style="width: 150px; height: 150px; object-fit: cover;" />
        </div>
    </div>

    @* Anti-Forgery 隱藏欄位：relation.js / notify.js 會從 DOM 中取出並附加在 AJAX 請求 *@
    @Html.AntiForgeryToken()

    @* 狀態提示（除錯用途）：顯示 Working / Result / Error 等字樣 先不顯示*@
    @* <div id="rel-status" class="mt-3 small text-muted"></div> *@

    @* 交友操作按鈕列（由 JS 動態插入）；若為本人或未登入則不顯示 *@
    <div id="relation-action-bar" class="d-flex justify-content-end gap-2 mt-2 p-2"></div>

    @* ===== 不公開提示卡片 =====
       - 目前不顯示貼文／好友等內容，僅顯示鎖頭提示
       - 使用了 Bootstrap Icons 的鎖頭圖示（bi-lock-fill），請確認版型已引用 bootstrap-icons
       ================================================= *@
    <div class="card text-center shadow-sm border-danger">
        <div class="card-body py-5">
            <h5 class="fw-semibold text-danger mb-3">
                <i class="bi bi-lock-fill"></i> 此小屋目前設定為不公開
            </h5>
            <p class="text-muted mb-0">
                僅屋主本人可查看貼文、好友清單與其他互動內容。
            </p>
        </div>
    </div>

    @* ===== Scripts 區段：佈局頁需有 @RenderSection("Scripts", required:false)
       這裡載入社交關係與通知的前端封裝，並初始化動作條與狀態同步
       ================================================================= *@
    @section Scripts {
        @* 封裝 sendRelationCommand：會自動附帶 Anti-Forgery、處理錯誤等 *@
        <script src="~/js/social_hub/relation.js"></script>

        @* 封裝 sendNotification：使用 Notifications/Ajax 建立通知 *@
        <script src="~/js/social_hub/notify.js"></script>

        <script>
            (function () {
                // =========================
                // 基本路由與參數（由 Razor 注入）
                // =========================
                // 關係操作（友請、接受、拒絕、封鎖...）
                var execUrl = '@Url.Action("Exec", "Relations", new { area = "social_hub" })';

                // 取得雙人關係資訊（狀態碼、請求發起者等）
                // TODO：目前為硬字串路徑；建議以 Url.Action("PairInfo","Relations", new { area="social_hub" }) 改寫，避免虛擬目錄問題
                var pairInfoUrl = '/social_hub/relations/pair-info';

                // 通知 AJAX 端點
                var ntfAjaxUrl = '@Url.Action("Ajax", "Notifications", new { area = "social_hub" })';

                // 目前登入者／小屋主
                var actorUserId = @currentLoggedInUserId; // 操作者
                var targetUserId = @targetUserId;         // 目標者

                // =========================
                // DOM 快取
                // =========================
                var bar = document.getElementById('relation-action-bar'); // 按鈕容器
                var statusEl = document.getElementById('rel-status');     // 除錯提示

                function setStatus(t) {
                    if (statusEl) statusEl.textContent = t || '';
                }

                // =========================
                // 依關係狀態動態渲染按鈕
                // 參數 rel 期待格式：{ statusCode: 'PENDING'|... , requestedBy: number }
                // =========================
                function renderButtons(rel) {
                    if (!bar) return;

                    // 首選伺服器回傳；若無，使用 Model 的初始值（避免首屏空白）
                    var status = (rel && rel.statusCode) || '@Model.CurrentRelationStatus';

                    // 請求發起者（若 rel 沒有，回退 Model 值；沒有則 0）
                    var requestedBy = (rel && typeof rel.requestedBy === 'number')
                        ? rel.requestedBy
                        : @(@Model.CurrentRelationRequestedByUserId.HasValue? Model.CurrentRelationRequestedByUserId.Value : 0);

                    // 本人小屋或未登入：不顯示按鈕（僅顯示狀態提示為空）
                    if (@(Model.IsOwner ? "true" : "false") || actorUserId === 0) {
                        bar.innerHTML = '';
                        setStatus('');
                        return;
                    }

                    // 除錯：顯示狀態碼（正式可移除）
                    setStatus(status ? ('Status: ' + status) : '');

                    // 依狀態碼產生按鈕（硬編狀態機；長期建議改 allowedActions）
                    var html = '';
                    switch (status) {
                        case 'NONE':
                            // 尚無關係：可加好友、可封鎖
                            html =
                                '<button class="btn btn-primary btn-sm" id="addFriendBtn">加為好友</button>' +
                                '<button class="btn btn-dark btn-sm ms-2" id="blockUserBtn">封鎖</button>';
                            break;

                        case 'PENDING':
                            // 等待回應：分「我發起」與「對方發起」
                            if (requestedBy === actorUserId) {
                                html = '<button class="btn btn-warning btn-sm" id="cancelFriendBtn">取消請求</button>';
                            } else {
                                html =
                                    '<button class="btn btn-success btn-sm" id="acceptFriendBtn">接受好友</button>' +
                                    '<button class="btn btn-danger btn-sm ms-2" id="rejectFriendBtn">拒絕好友</button>';
                            }
                            html += '<button class="btn btn-dark btn-sm ms-2" id="blockUserBtn">封鎖</button>';
                            break;

                        case 'ACCEPTED':
                            // 已互為好友：可解除、可封鎖
                            html =
                                '<button class="btn btn-outline-danger btn-sm" id="unfriendBtn">解除好友</button>' +
                                '<button class="btn btn-dark btn-sm ms-2" id="blockUserBtn">封鎖</button>';
                            break;

                        case 'BLOCKED':
                            // 封鎖狀態：僅允許解除封鎖
                            html = '<button class="btn btn-secondary btn-sm" id="unblockUserBtn">解除封鎖</button>';
                            break;

                        case 'REMOVED':
                        case 'REJECTED':
                            // 曾發生關係但目前非好友：與 NONE 類似
                            html =
                                '<button class="btn btn-primary btn-sm" id="addFriendBtn">加為好友</button>' +
                                '<button class="btn btn-dark btn-sm ms-2" id="blockUserBtn">封鎖</button>';
                            break;
                    }

                    // 寫入容器：每次重繪會覆蓋舊節點，避免重複事件
                    bar.innerHTML = html;

                    // ====== 可能送出通知（成功且有狀態變更時） ======
                    function maybeNotify(action) {
                        // 若無 notify.js（sendNotification）則靜默略過
                        if (typeof window.sendNotification !== 'function') return;

                        // 顯示字串映射（純前端展示）
                        var titleMap = {
                            friend_request: '好友邀請',
                            accept: '好友邀請已接受',
                            reject: '好友邀請已拒絕',
                            cancel_request: '好友邀請已取消',
                            unfriend: '已解除好友',
                            block: '封鎖通知',
                            unblock: '解除封鎖通知'
                        };
                        var msgMap = {
                            friend_request: '使用者 #' + actorUserId + ' 邀請你成為好友',
                            accept: '使用者 #' + actorUserId + ' 接受了你的好友邀請',
                            reject: '使用者 #' + actorUserId + ' 拒絕了你的好友邀請',
                            cancel_request: '使用者 #' + actorUserId + ' 取消了對你的好友邀請',
                            unfriend: '使用者 #' + actorUserId + ' 將你從好友中移除',
                            block: '使用者 #' + actorUserId + ' 封鎖了你',
                            unblock: '使用者 #' + actorUserId + ' 已解除對你的封鎖'
                        };

                        // NOTE：此處硬編 actionId。依你的擴充規範，建議改由伺服器回傳對照表。
                        var actionId = (action === 'friend_request') ? 6 : 1;

                        // 實際送出通知（notify.js 會處理 Anti-Forgery 與 AJAX）
                        var payload = {
                            sourceId: 1,
                            actionId: actionId,
                            toUserId: targetUserId,
                            title: titleMap[action] || '通知',
                            message: msgMap[action] || ''
                        };
                        window.sendNotification({ url: ntfAjaxUrl, payload: payload });
                    }

                    // ====== 綁定按鈕事件：送出關係指令 → 視情況送通知 → 刷新狀態 ======
                    function bind(id, h) {
                        var el = document.getElementById(id);
                        if (el) el.addEventListener('click', h);
                    }

                    // 共用送指令函式：呼叫 relation.js 的 sendRelationCommand
                    function sendCmd(cmd) {
                        setStatus('Working...');
                        if (typeof window.sendRelationCommand !== 'function') {
                            setStatus('Function not loaded');
                            return Promise.resolve({ succeeded: false });
                        }
                        // TODO：如需避免連點，可在此將 bar 內按鈕 disabled，完成後還原
                        return window.sendRelationCommand({ url: execUrl, command: cmd })
                            .then(function (r) {
                                setStatus(r.succeeded
                                    ? ('Result: ' + (r.newStatusCode || '') + ' (NoOp: ' + r.noOp + ')')
                                    : ('Error: ' + r.reason));
                                return r;
                            })
                            .catch(function (e) {
                                setStatus('Error: ' + e.message);
                                return { succeeded: false };
                            });
                    }

                    // 友請
                    bind('addFriendBtn', function () {
                        sendCmd({ actorUserId: actorUserId, targetUserId: targetUserId, actionCode: 'friend_request' })
                            .then(function (r) { if (r && r.succeeded && !r.noOp) maybeNotify('friend_request'); refreshRelation(); });
                    });

                    // 接受友請
                    bind('acceptFriendBtn', function () {
                        sendCmd({ actorUserId: actorUserId, targetUserId: targetUserId, actionCode: 'accept' })
                            .then(function (r) { if (r && r.succeeded && !r.noOp) maybeNotify('accept'); refreshRelation(); });
                    });

                    // 拒絕友請
                    bind('rejectFriendBtn', function () {
                        if (confirm('您確定要拒絕此好友邀請嗎？')) {
                            sendCmd({ actorUserId: actorUserId, targetUserId: targetUserId, actionCode: 'reject' })
                                .then(function (r) { if (r && r.succeeded && !r.noOp) maybeNotify('reject'); refreshRelation(); });
                        }
                    });

                    // 取消我發起的友請
                    bind('cancelFriendBtn', function () {
                        if (confirm('您確定要取消已送出的好友邀請嗎？')) {
                            sendCmd({ actorUserId: actorUserId, targetUserId: targetUserId, actionCode: 'cancel_request' })
                                .then(function (r) { if (r && r.succeeded && !r.noOp) maybeNotify('cancel_request'); refreshRelation(); });
                        }
                    });

                    // 解除好友
                    bind('unfriendBtn', function () {
                        if (confirm('您確定要解除好友關係嗎？')) {
                            sendCmd({ actorUserId: actorUserId, targetUserId: targetUserId, actionCode: 'unfriend' })
                                .then(function (r) { if (r && r.succeeded && !r.noOp) maybeNotify('unfriend'); refreshRelation(); });
                        }
                    });

                    // 封鎖／解除封鎖
                    bind('blockUserBtn', function () {
                        if (confirm('您確定要封鎖此使用者嗎？封鎖後將無法再收到對方的訊息。')) {
                            sendCmd({ actorUserId: actorUserId, targetUserId: targetUserId, actionCode: 'block' })
                                .then(function (r) { if (r && r.succeeded && !r.noOp) maybeNotify('block'); refreshRelation(); });
                        }
                    });
                    bind('unblockUserBtn', function () {
                        if (confirm('您確定要解除封鎖此使用者嗎？')) {
                            sendCmd({ actorUserId: actorUserId, targetUserId: targetUserId, actionCode: 'unblock' })
                                .then(function (r) { if (r && r.succeeded && !r.noOp) maybeNotify('unblock'); refreshRelation(); });
                        }
                    });
                }

                // =========================
                // 從伺服器取得雙人關係（狀態同步）
                // =========================
                function fetchPairInfo() {
                    // credentials: 'same-origin' 會帶上現有 Cookie（含身份）
                    var url = pairInfoUrl + '?a=' + actorUserId + '&b=' + targetUserId;
                    return fetch(url, { credentials: 'same-origin' })
                        .then(function (res) {
                            if (!res.ok) throw new Error('HTTP ' + res.status);
                            return res.json();
                        })
                        .catch(function (err) {
                            // 回退：沿用 Model 初始狀態，避免 UI 中斷
                            return {
                                statusCode: '@Model.CurrentRelationStatus',
                                requestedBy: @(@Model.CurrentRelationRequestedByUserId.HasValue? Model.CurrentRelationRequestedByUserId.Value : 0)
                            };
                        });
                }

                // 重新整理關係：抓一次最新 → 重繪按鈕
                function refreshRelation() {
                    fetchPairInfo().then(function (rel) { renderButtons(rel); });
                }

                // =========================
                // 首屏：先用 Model 值快速畫一次，再同步伺服器
                // =========================
                document.addEventListener('DOMContentLoaded', function () {
                    renderButtons({
                        statusCode: '@Model.CurrentRelationStatus',
                        requestedBy: @(@Model.CurrentRelationRequestedByUserId.HasValue? Model.CurrentRelationRequestedByUserId.Value : 0)
                    });
                    refreshRelation();
                });
            })();
        </script>
    }
</div>
